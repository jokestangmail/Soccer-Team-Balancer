<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Team Balancer</title>
<style>
:root{
  --bg:#F6F7FB;
  --card:#FFFFFF;
  --border:#E5E7EF;
  --text:#0B1220;
  --muted:#667085;
  --blue:#0A84FF;
  --shadow: 0 10px 30px rgba(10, 20, 40, 0.08);
  --r:18px;
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:-apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial;
  background:var(--bg);
  color:var(--text);
}
.app{
  max-width:440px;
  margin:0 auto;
  padding:14px 14px 110px;
}
.topbar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:10px;
}
.brand{
  display:flex; align-items:center; gap:10px;
}
.logo{
  width:34px;height:34px;border-radius:12px;
  background:linear-gradient(135deg,#0A84FF,#34C759);
  box-shadow: var(--shadow);
  position:relative;
}
.logo:after{
  content:"TB";
  position:absolute; inset:0;
  display:flex; align-items:center; justify-content:center;
  color:#fff; font-weight:900; font-size:13px;
  letter-spacing:0.6px;
}
h1{
  margin:0;
  font-size:18px;
  font-weight:900;
  letter-spacing:0.2px;
}
.tabs{
  display:flex;
  gap:8px;
  background:rgba(255,255,255,0.7);
  border:1px solid var(--border);
  padding:6px;
  border-radius:999px;
  position:sticky;
  top:10px;
  z-index:10;
  backdrop-filter: blur(10px);
}
.tab{
  flex:1;
  padding:10px 12px;
  border-radius:999px;
  border:0;
  background:transparent;
  font-weight:900;
  color:var(--muted);
}
.tab.active{
  background:var(--card);
  color:var(--text);
  box-shadow: 0 8px 18px rgba(10, 20, 40, 0.08);
}
.card{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:var(--r);
  box-shadow: 0 1px 0 rgba(10,20,40,0.03);
  padding:14px;
  margin-top:12px;
}
.row{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:10px;
  padding:12px;
  border:1px solid var(--border);
  border-radius:16px;
  background:#fff;
  margin-bottom:10px;
  cursor:pointer;
}
.row.alt{background:#FBFCFF}
.row.selected{
  border-color: rgba(10,132,255,0.45);
  background:#EAF2FF;
}
.left{min-width:0; flex:1}
.name{
  font-size:16px;
  font-weight:900;
  line-height:1.1;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.meta{
  font-size:12px;
  color:var(--muted);
  margin-top:4px;
}
.roleChips{display:flex; gap:6px; margin-top:8px; flex-wrap:wrap}
.chip{
  padding:5px 10px;
  border-radius:999px;
  font-size:11px;
  font-weight:900;
  letter-spacing:0.15px;
  border:1px solid rgba(0,0,0,0.06);
}
.chipF{background:#FEE2E2;color:#991B1B}
.chipM{background:#DCFCE7;color:#166534}
.chipD{background:#DBEAFE;color:#1D4ED8}

.strength{
  margin-top:10px;
  display:flex;
  align-items:center;
  gap:10px;
}
.bar{
  flex:1;
  height:10px;
  border-radius:999px;
  background:#EEF1F7;
  overflow:hidden;
}
.fill{height:100%}
.num{
  min-width:40px;
  text-align:right;
  font-size:12px;
  font-weight:900;
  color:var(--muted);
}
.badge{
  width:30px;height:30px;border-radius:12px;
  display:flex;align-items:center;justify-content:center;
  font-weight:900;
  color:var(--blue);
  background:rgba(10,132,255,0.10);
  border:1px solid rgba(10,132,255,0.18);
  flex:0 0 auto;
  margin-top:2px;
}
.badge.on{color:#fff;background:var(--blue);border-color:rgba(10,132,255,0.65)}

.controls{
  display:flex; gap:10px; flex-wrap:wrap;
}
select,input[type="text"]{
  width:100%;
  padding:12px 12px;
  border-radius:14px;
  border:1px solid var(--border);
  background:#fff;
  font-weight:700;
  outline:none;
}
.small{font-size:12px;color:var(--muted);margin-top:8px}

.stickyBar{
  position:fixed;
  left:0; right:0; bottom:0;
  padding:12px 14px calc(12px + env(safe-area-inset-bottom));
  background:rgba(255,255,255,0.88);
  border-top:1px solid var(--border);
  backdrop-filter: blur(12px);
}
.stickyInner{
  max-width:440px;
  margin:0 auto;
  display:flex;
  gap:10px;
  align-items:center;
}
.primary{
  flex:1;
  border:0;
  background:var(--blue);
  color:#fff;
  padding:14px 14px;
  border-radius:16px;
  font-weight:900;
  font-size:15px;
}
.secondary{
  border:1px solid var(--border);
  background:#fff;
  color:var(--text);
  padding:14px 14px;
  border-radius:16px;
  font-weight:900;
  font-size:15px;
}
.secondary.smallBtn{padding:12px 12px; font-size:14px}
.btnRow{display:flex; gap:10px; margin-top:10px}
.btnRow .secondary{flex:1}
.btnRow .primary{flex:1}

.teamCard{
  border-radius:20px;
  overflow:hidden;
  border:1px solid var(--border);
  background:#fff;
  margin-top:12px;
}
.teamHeader{
  padding:12px 12px;
  color:#fff;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  font-weight:900;
}
.teamTitle{display:flex; align-items:center; gap:10px}
.shirt{
  width:22px;height:18px;border-radius:4px 4px 8px 8px;
  background:rgba(255,255,255,0.25);
  border:1px solid rgba(255,255,255,0.35);
}
.teamMeta{font-size:12px; opacity:0.92; text-align:right; line-height:1.2}

.c-red{background:#EB5757}
.c-white{background:#E5E7EB; color:#111}
.c-black{background:#111}
.c-blue{background:#2563EB}

.playerLine{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 12px;
  border-bottom:1px solid #F0F2F6;
  gap:12px;
}
.playerLine:last-child{border-bottom:none}
.pn{
  font-weight:900;
  min-width:0;
  flex:1;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

/* Final teams role columns */
.roleGrid{
  display:grid;
  grid-template-columns: 42px 42px 42px;
  column-gap:14px;
  align-items:center;
  justify-content:start; /* not right-justified */
  flex:0 0 auto;
}
.roleDot{
  width:26px;height:26px;
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  font-size:12px;
  border:1px solid rgba(0,0,0,0.10);
}
.dotF{background:#FEE2E2;color:#991B1B}
.dotM{background:#DCFCE7;color:#166534}
.dotD{background:#DBEAFE;color:#1D4ED8}
.dotOff{visibility:hidden}

/* Modal */
.modalBackdrop{
  position:fixed; inset:0;
  background:rgba(8,14,25,0.45);
  display:none;
  align-items:flex-end;
  justify-content:center;
  padding:12px 12px calc(12px + env(safe-area-inset-bottom));
  z-index:50;
}
.modal{
  width:100%;
  max-width:440px;
  background:#fff;
  border-radius:22px;
  border:1px solid var(--border);
  box-shadow: var(--shadow);
  padding:14px;
}
.modalHeader{
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  margin-bottom:10px;
}
.modalHeader h3{margin:0; font-size:16px; font-weight:900}
.modalGrid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}
label{font-size:12px; font-weight:800; color:var(--muted); display:block; margin-bottom:6px}
.field input[type="number"], .field input[type="text"]{
  width:100%;
  padding:12px 12px;
  border-radius:14px;
  border:1px solid var(--border);
  font-weight:800;
}
.roleToggle{display:flex; gap:8px; flex-wrap:wrap; margin-top:6px}
.roleToggle button{
  border:1px solid var(--border);
  background:#fff;
  padding:10px 12px;
  border-radius:999px;
  font-weight:900;
}
.roleToggle button.onF{background:#FEE2E2;color:#991B1B;border-color:#FECACA}
.roleToggle button.onM{background:#DCFCE7;color:#166534;border-color:#BBF7D0}
.roleToggle button.onD{background:#DBEAFE;color:#1D4ED8;border-color:#BFDBFE}
.modalActions{display:flex; gap:10px; margin-top:12px}
.modalActions .primary{flex:1}
.modalActions .secondary{flex:1}
.danger{background:#fff;border:1px solid #FCA5A5;color:#991B1B}
.hidden{display:none}
.empty{
  color:var(--muted);
  font-weight:800;
  font-size:13px;
  padding:10px 6px;
}

/* Scrollable checklist (keeps Generate/Results reachable) */
#checklist{
  max-height: 52vh;
  overflow:auto;
  -webkit-overflow-scrolling: touch;
  padding-right: 2px;
}

</style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>Team Balancer</h1>
        <div class="small" id="subtitle">Build tonight’s game, then generate balanced teams.</div>
      </div>
    </div>
  </div>

  <div class="tabs" role="tablist" aria-label="Main tabs">
    <button class="tab active" id="tabGame" onclick="switchTab('game')" role="tab">Game Builder</button>
    <button class="tab" id="tabPlayers" onclick="switchTab('players')" role="tab">Players</button>
  </div>

  <!-- GAME -->
  <div id="pageGame">
    <div class="card">
      <div class="controls">
        <label for="teamCount">Number of games</label>
        <select id="teamCount" onchange="onTeamCountChange()">
          <option value="2">1 game (2 teams)</option>
          <option value="4">2 games (4 teams)</option>
        </select>
      </div>
      <div class="small"><span id="selectedCount">0</span> selected</div>
      <div class="btnRow">
        <button class="secondary" onclick="clearSelection()">Clear</button>
        <button class="secondary" onclick="regenerate()">Regenerate</button>
      </div>
    </div>

    <div id="results"></div>
    <div id="resultsEmpty" class="empty">Select players above, then tap “Generate Teams”.</div>
  <div class="card">
      <label for="gameSearch">Tonight’s players</label>
      <input id="gameSearch" type="text" placeholder="Search players…" oninput="renderChecklist()"/>
      <div id="checklist" style="margin-top:12px;"></div>
    </div>

    </div>

  <!-- PLAYERS -->
  <div id="pagePlayers" class="hidden">
    <div class="card">
      <div class="controls">
        <label for="playerSearch">Players database</label>
        <input id="playerSearch" type="text" placeholder="Search players…" oninput="renderPlayersPage()"/>
      </div>
      <div class="btnRow">
        <button class="secondary" onclick="openModal(null)">Add Player</button>
        <button class="secondary" onclick="exportJSON()">Export JSON</button>
      </div>
      <div class="btnRow">
        <button class="secondary" onclick="importJSON()">Import JSON</button>
        <button class="danger secondary" onclick="randomizeDemo()">Randomize Demo</button>
      </div>
      <div id="playersList" style="margin-top:12px;"></div>
    </div>
  </div>
</div>

<!-- Sticky generate -->
<div class="stickyBar">
  <div class="stickyInner">
    <button class="primary" id="btnGenerate" onclick="generateTeams()">Generate Teams</button>
  </div>
</div>

<!-- Modal -->
<div class="modalBackdrop" id="modalBackdrop" onclick="backdropClose(event)">
  <div class="modal" onclick="event.stopPropagation()">
    <div class="modalHeader">
      <h3 id="modalTitle">Player</h3>
      <button class="secondary smallBtn" onclick="closeModal()">Done</button>
    </div>

    <div class="field">
      <label>Name</label>
      <input type="text" id="fName" placeholder="Player name"/>
    </div>

    <div class="field" style="margin-top:10px;">
      <label>Roles</label>
      <div class="roleToggle">
        <button id="btnF" onclick="toggleRole('F')">Forward</button>
        <button id="btnM" onclick="toggleRole('M')">Mid</button>
        <button id="btnD" onclick="toggleRole('D')">Defense</button>
      </div>
      <div class="small">Tap to toggle roles. Players can have 1–3 roles.</div>
    </div>

    <div class="card" style="margin-top:12px; box-shadow:none;">
      <div class="small" style="margin-bottom:8px; font-weight:900; color:var(--text)">Ratings</div>
      <div class="modalGrid">
        <div class="field"><label>Overall (1–10)</label><input id="rOverall" type="number" min="1" max="10"></div>
        <div class="field"><label>Passing (1–10)</label><input id="rPassing" type="number" min="1" max="10"></div>
        <div class="field"><label>Dribbling (1–10)</label><input id="rDribbling" type="number" min="1" max="10"></div>
        <div class="field"><label>Finishing (1–10)</label><input id="rFinishing" type="number" min="1" max="10"></div>
        <div class="field"><label>Defense (1–10)</label><input id="rDefense" type="number" min="1" max="10"></div>
        <div class="field"><label>Speed (1–10)</label><input id="rSpeed" type="number" min="1" max="10"></div>
        <div class="field"><label>Stamina (1–10)</label><input id="rStamina" type="number" min="1" max="10"></div>
        <div class="field"><label>Clutch (1–5)</label><input id="rClutch" type="number" min="1" max="5"></div>
        <div class="field"><label>Consistency (1–5)</label><input id="rConsistency" type="number" min="1" max="5"></div>
        <div class="field"><label>Leadership (1–5)</label><input id="rLeadership" type="number" min="1" max="5"></div>
      </div>
      <div class="small">Invalid values are blocked (out of range).</div>
    </div>

    <div class="modalActions">
      <button class="danger secondary" id="btnDelete" onclick="deleteCurrent()">Delete</button>
      <button class="primary" onclick="saveCurrent()">Save</button>
    </div>
  </div>
</div>

<script>
/* =========================
   Storage + Preload
   ========================= */
const LS_PLAYERS = 'tb_players_v1';
const LS_SELECTION = 'tb_selection_v1';

const PRELOAD_NAMES = ["Adnan","Tomek","Mike","Guido","Achkan","Tuto","Carlos","Max C","Kiaan","Matt","Danny","Kadir","Mateo","Hugo","Ciro","Orson","Luismi","Marcelo","Arya","Brandon","Mario","Juan","Max K","Roger","Andy","Devrim","Conrad","Alex"];

function uid(){ return (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Date.now()) + Math.random().toString(16).slice(2); }

function clampInt(v, lo, hi){
  const n = Number(v);
  if(!Number.isFinite(n)) return lo;
  return Math.max(lo, Math.min(hi, Math.round(n)));
}

function defaultRatings(){
  // reasonable defaults
  const overall = clampInt(6 + Math.random()*2, 1, 10);
  return {
    overall,
    passing: clampInt(overall + (Math.random()*2-1),1,10),
    dribbling: clampInt(overall + (Math.random()*2-1),1,10),
    finishing: clampInt(overall + (Math.random()*2-1),1,10),
    defense: clampInt(overall + (Math.random()*2-1),1,10),
    speed: clampInt(overall + (Math.random()*2-1),1,10),
    stamina: clampInt(overall + (Math.random()*2-1),1,10),
    clutch: clampInt(3 + (Math.random()*2-1),1,5),
    consistency: clampInt(3 + (Math.random()*2-1),1,5),
    leadership: clampInt(3 + (Math.random()*2-1),1,5),
  };
}

function preloadPlayers(){
  // Make roles a bit more distinct (so the role-balancing feature is easy to test)
  // We'll rotate patterns across players.
  const patterns = [
    {F:true,M:true,D:false},
    {F:true,M:false,D:true},
    {F:false,M:true,D:true},
    {F:true,M:false,D:false},
    {F:false,M:true,D:false},
    {F:false,M:false,D:true},
    {F:true,M:true,D:true},
  ];
  return PRELOAD_NAMES.map((name, i) => ({
    id: uid(),
    name,
    roles: {...patterns[i % patterns.length]},
    ratings: defaultRatings(),
  }));
}

let players = [];
let selection = new Set();
let currentEditId = null;
let lastSolution = null; // for regenerate variety

function load(){
  const raw = localStorage.getItem(LS_PLAYERS);
  if(raw){
    try{
      const arr = JSON.parse(raw);
      if(Array.isArray(arr) && arr.length){
        players = arr.map(p=>({
          id: p.id || uid(),
          name: (p.name||'').toString(),
          roles: {F:!!p.roles?.F, M:!!p.roles?.M, D:!!p.roles?.D},
          ratings: {
            overall: clampInt(p.ratings?.overall ?? 6,1,10),
            passing: clampInt(p.ratings?.passing ?? 6,1,10),
            dribbling: clampInt(p.ratings?.dribbling ?? 6,1,10),
            finishing: clampInt(p.ratings?.finishing ?? 6,1,10),
            defense: clampInt(p.ratings?.defense ?? 6,1,10),
            speed: clampInt(p.ratings?.speed ?? 6,1,10),
            stamina: clampInt(p.ratings?.stamina ?? 6,1,10),
            clutch: clampInt(p.ratings?.clutch ?? 3,1,5),
            consistency: clampInt(p.ratings?.consistency ?? 3,1,5),
            leadership: clampInt(p.ratings?.leadership ?? 3,1,5),
          }
        }));
      } else {
        players = preloadPlayers();
      }
    }catch(e){
      players = preloadPlayers();
    }
  } else {
    players = preloadPlayers();
  }

  const selRaw = localStorage.getItem(LS_SELECTION);
  if(selRaw){
    try{
      const ids = JSON.parse(selRaw);
      if(Array.isArray(ids)) selection = new Set(ids.filter(id=>players.some(p=>p.id===id)));
    }catch(e){}
  }
  save();
}

function save(){
  localStorage.setItem(LS_PLAYERS, JSON.stringify(players));
  localStorage.setItem(LS_SELECTION, JSON.stringify([...selection]));
}

function $(id){ return document.getElementById(id); }
function displayName(p){ return (p && p.name && String(p.name).trim()) ? String(p.name).trim() : '(No name)'; }

/* =========================
   Scoring + Optimization
   ========================= */
function computeScore(p){
  const r = p.ratings;
  // fixed weights (no UI tuning)
  return (r.overall*3.0) +
    ((r.passing + r.dribbling + r.finishing + r.defense)*1.5) +
    ((r.speed + r.stamina)*1.2) +
    (r.clutch*1.2) +
    (r.consistency*1.0) +
    (r.leadership*1.0);
}

function strengthPct(score){
  // normalize to 0-100 range using expected bounds
  // min: overall1 etc -> ~ (1*3)+(4*1.5)+(2*1.2)+(1.2+1+1)=3+6+2.4+3.2=14.6
  // max: overall10 etc -> 30+60+24+ (6+5+5)=130
  const min=14.6, max=130;
  const pct = ((score-min)/(max-min))*100;
  return Math.max(0, Math.min(100, pct));
}
function strengthColor(pct){
  // green to orange to red-ish (keep subtle)
  if(pct>=75) return "#34C759";
  if(pct>=55) return "#FF9F0A";
  return "#FF453A";
}

function std(arr){
  const n=arr.length;
  if(n<=1) return 0;
  const mean = arr.reduce((s,x)=>s+x,0)/n;
  const v = arr.reduce((s,x)=>s+(x-mean)*(x-mean),0)/n;
  return Math.sqrt(v);
}

/* Role logic
   - Soft positional balance: penalize spread in role distribution
   - Strict coverage: if pool has >= teamCount for a role, enforce at least one per team
*/
function roleCap(p){ const r=p.roles||{}; return {F:!!r.F, M:!!r.M, D:!!r.D}; }
function teamHasRole(team, role){ return team.some(p=>roleCap(p)[role]); }
function teamRoleCounts(team){
  let F=0,M=0,D=0;
  for(const p of team){ const c=roleCap(p); if(c.F)F++; if(c.M)M++; if(c.D)D++; }
  return {F,M,D};
}

function computeObjective(teams, globalRoleCounts, lambdaRole){
  const totals = teams.map(t=>t.reduce((s,p)=>s+p._score,0));
  const avgs = teams.map((t,i)=>totals[i]/Math.max(1,t.length));
  const primary = std(avgs);

  // capability spread
  const caps = teams.map(teamRoleCounts);
  const meanF = caps.reduce((s,x)=>s+x.F,0)/teams.length;
  const meanM = caps.reduce((s,x)=>s+x.M,0)/teams.length;
  const meanD = caps.reduce((s,x)=>s+x.D,0)/teams.length;
  const spread = (k,mean)=> caps.reduce((s,x)=>s+Math.abs(x[k]-mean),0)/teams.length;
  const capImbalance = spread('F',meanF) + 0.9*spread('M',meanM) + spread('D',meanD);

  // missing role penalty when pool allows it
  const k = teams.length;
  let missing = 0;
  if((globalRoleCounts.F||0) >= k) missing += caps.reduce((s,x)=>s+(x.F<=0?1:0),0);
  if((globalRoleCounts.M||0) >= k) missing += caps.reduce((s,x)=>s+(x.M<=0?1:0),0)*0.8;
  if((globalRoleCounts.D||0) >= k) missing += caps.reduce((s,x)=>s+(x.D<=0?1:0),0);

  const rolePenalty = (capImbalance*0.55) + (missing*2.5);
  const objective = primary + (lambdaRole||0)*rolePenalty;
  return {objective, primary, rolePenalty};
}

function cloneTeams(teams){ return teams.map(t=>t.slice()); }

function enforceMinRolesStrict(teams, globalRoleCounts, lambdaRole){
  const k = teams.length;
  const required = [];
  if((globalRoleCounts.F||0) >= k) required.push('F');
  if((globalRoleCounts.M||0) >= k) required.push('M');
  if((globalRoleCounts.D||0) >= k) required.push('D');
  if(required.length===0) return teams;

  function okTeam(team){ return required.every(r=>teamHasRole(team,r)); }

  // Iterate until all required are satisfied or we get stuck
  for(let pass=0; pass<12; pass++){
    let changed=false;
    for(const role of required){
      for(let recv=0; recv<teams.length; recv++){
        if(teamHasRole(teams[recv], role)) continue;

        let best=null;

        for(let donor=0; donor<teams.length; donor++){
          if(donor===recv) continue;
          const donorTeam = teams[donor];
          if(teamRoleCounts(donorTeam)[role] < 2) continue;

          const recvTeam = teams[recv];

          for(let a=0;a<donorTeam.length;a++){
            const give = donorTeam[a];
            if(!roleCap(give)[role]) continue;

            const donorMinus = donorTeam.filter((_,x)=>x!==a);
            if(!okTeam(donorMinus)) continue;

            for(let b=0;b<recvTeam.length;b++){
              const take = recvTeam[b];
              const donorAfter = donorMinus.concat([take]);
              const recvAfter = recvTeam.filter((_,x)=>x!==b).concat([give]);
              if(!okTeam(donorAfter)) continue;
              if(!okTeam(recvAfter)) continue;

              const before = computeObjective(teams, globalRoleCounts, lambdaRole).objective;

              // swap in place for eval
              const tmp = recvTeam[b];
              recvTeam[b]=give;
              donorTeam[a]=take;
              const after = computeObjective(teams, globalRoleCounts, lambdaRole).objective;
              // revert
              donorTeam[a]=give;
              recvTeam[b]=tmp;

              const delta = after - before;
              if(best===null || delta < best.delta){
                best={donor,recv,a,b,delta};
              }
            }
          }
        }

        if(best){
          const donorTeam = teams[best.donor];
          const recvTeam = teams[best.recv];
          const give = donorTeam[best.a];
          const take = recvTeam[best.b];
          donorTeam[best.a]=take;
          recvTeam[best.b]=give;
          changed=true;
        }
      }
    }
    if(!changed) break;
  }
  return teams;
}

// Seeding
function greedySeed(arr, teamCount, rand){
  const teams = Array.from({length:teamCount},()=>[]);
  const totals = Array.from({length:teamCount},()=>0);
  const sizes  = Array.from({length:teamCount},()=>0);

  const sorted = arr.slice().sort((a,b)=>b._score-a._score);
  for(const p of sorted){
    // pick team with lowest normalized avg so far (tot/size), tie-breaker by size
    let best=0, bestVal=Infinity;
    for(let i=0;i<teamCount;i++){
      const val = totals[i]/Math.max(1,sizes[i]);
      const tie = sizes[i]*0.0001;
      const v = val + tie;
      if(v<bestVal){ bestVal=v; best=i; }
    }
    teams[best].push(p);
    totals[best]+=p._score;
    sizes[best]++;
  }
  return teams;
}
function randomSeed(arr, teamCount, rand){
  const teams = Array.from({length:teamCount},()=>[]);
  const pool = arr.slice();
  for(let i=pool.length-1;i>0;i--){
    const j = Math.floor(rand()* (i+1));
    [pool[i],pool[j]]=[pool[j],pool[i]];
  }
  for(let i=0;i<pool.length;i++){
    teams[i%teamCount].push(pool[i]);
  }
  return teams;
}

function optimize(selected, teamCount, seed){
  // deterministic-ish RNG for regenerate variety
  let s = seed || Math.floor(Math.random()*1e9);
  const rand = ()=> (s = (s*1664525 + 1013904223) >>> 0) / 4294967296;

  const arr = selected.map(p=>({ ...p, _score: computeScore(p) }));
  const n = arr.length;
  const small = n<=20;
  const restarts = small?24:(n<=28?14:9);
  const attempts = small?4200:(n<=28?3000:2400);

  const globalRoleCounts = {
    F: arr.filter(p=>p.roles?.F).length,
    M: arr.filter(p=>p.roles?.M).length,
    D: arr.filter(p=>p.roles?.D).length,
  };
  const lambdaRole = 0.95;

  let bestTeams=null;
  let bestEval={objective:Infinity};

  for(let r=0;r<restarts;r++){
    const base = (r%2===0) ? greedySeed(arr, teamCount, rand) : randomSeed(arr, teamCount, rand);

    // strict coverage if possible
    enforceMinRolesStrict(base, globalRoleCounts, lambdaRole);

    let cur = base;
    let curEval = computeObjective(cur, globalRoleCounts, lambdaRole);
    if(curEval.objective < bestEval.objective){ bestEval=curEval; bestTeams=cloneTeams(cur); }

    // swap hillclimb
    for(let t=0;t<attempts;t++){
      // pick 2 distinct teams with players
      let a = Math.floor(rand()*teamCount);
      let b = Math.floor(rand()*teamCount);
      if(a===b) continue;
      if(cur[a].length===0 || cur[b].length===0) continue;

      const ia = Math.floor(rand()*cur[a].length);
      const ib = Math.floor(rand()*cur[b].length);

      const cand = cloneTeams(cur);
      const pa = cand[a][ia];
      const pb = cand[b][ib];
      cand[a][ia]=pb;
      cand[b][ib]=pa;

      // enforce role coverage if possible
      enforceMinRolesStrict(cand, globalRoleCounts, lambdaRole);

      const ev = computeObjective(cand, globalRoleCounts, lambdaRole);
      if(ev.objective <= curEval.objective){
        cur = cand;
        curEval = ev;
        if(ev.objective < bestEval.objective){
          bestEval = ev;
          bestTeams = cloneTeams(cand);
        }
      }
    }
  }

  // final strict check
  enforceMinRolesStrict(bestTeams, {
    F: bestTeams.flat().filter(p=>p.roles?.F).length,
    M: bestTeams.flat().filter(p=>p.roles?.M).length,
    D: bestTeams.flat().filter(p=>p.roles?.D).length,
  }, 0.95);

  const totals = bestTeams.map(t=>t.reduce((s,p)=>s+p._score,0));
  const avgs = bestTeams.map((t,i)=>totals[i]/Math.max(1,t.length));
  return {teams:bestTeams, totals, avgs, eval:bestEval, seed:s};
}

/* =========================
   Rendering
   ========================= */
function switchTab(tab){
  const game = $('pageGame');
  const playersPage = $('pagePlayers');
  $('tabGame').classList.toggle('active', tab==='game');
  $('tabPlayers').classList.toggle('active', tab==='players');
  game.classList.toggle('hidden', tab!=='game');
  playersPage.classList.toggle('hidden', tab!=='players');

  // Sticky bar always for generate (works from anywhere), but only meaningful on game tab
  $('subtitle').textContent = (tab==='game')
    ? "Build tonight’s game, then generate balanced teams."
    : "Manage your master player list (saved on your device).";

  if(tab==='players') renderPlayersPage();
  if(tab==='game') renderChecklist();
}

function updateSticky(){
  $('selectedCount').textContent = String(selection.size);
  $('btnGenerate').textContent = selection.size ? `Generate Teams (${selection.size})` : "Generate Teams";
}

function renderChecklist(){
  const q = ($('gameSearch').value||'').toLowerCase().trim();
  const list = players.slice()
    .sort((a,b)=>displayName(a).localeCompare(displayName(b)))
    .filter(p=> !q || displayName(p).toLowerCase().includes(q));

  const wrap = $('checklist');
  wrap.innerHTML = '';

  if(list.length===0){
    wrap.innerHTML = `<div class="empty">${q ? 'No match.' : 'No players yet.'}</div>`;
    return;
  }

  list.forEach((p, idx)=>{
    const row = document.createElement('div');
    row.className = 'row ' + (idx%2===1 ? 'alt' : '');
    if(selection.has(p.id)) row.classList.add('selected');

    row.addEventListener('click', ()=>{
      if(selection.has(p.id)) selection.delete(p.id);
      else selection.add(p.id);
      save();
      lastSolution=null;
      renderResults(null);
      renderChecklist();
      updateSticky();
    });

    const left = document.createElement('div');
    left.className='left';

    const nm = document.createElement('div');
    nm.className='name';
    nm.textContent = displayName(p);

    const meta = document.createElement('div');
    meta.className='meta';
    meta.textContent = `Overall ${p.ratings.overall}`;

    const chips = document.createElement('div');
    chips.className='roleChips';
    if(p.roles.F){ const c=document.createElement('span'); c.className='chip chipF'; c.textContent='F'; chips.appendChild(c); }
    if(p.roles.M){ const c=document.createElement('span'); c.className='chip chipM'; c.textContent='M'; chips.appendChild(c); }
    if(p.roles.D){ const c=document.createElement('span'); c.className='chip chipD'; c.textContent='D'; chips.appendChild(c); }

    left.appendChild(nm);
    left.appendChild(meta);
    left.appendChild(chips);

    const badge = document.createElement('div');
    badge.className = 'badge' + (selection.has(p.id) ? ' on' : '');
    badge.textContent = selection.has(p.id) ? '✓' : '+';

    row.appendChild(left);
    row.appendChild(badge);
    wrap.appendChild(row);
  });
}

function renderPlayersPage(){
  const q = ($('playerSearch').value||'').toLowerCase().trim();
  const list = players.slice()
    .sort((a,b)=>displayName(a).localeCompare(displayName(b)))
    .filter(p=> !q || displayName(p).toLowerCase().includes(q));

  const wrap = $('playersList');
  wrap.innerHTML = '';

  if(list.length===0){
    wrap.innerHTML = `<div class="empty">${q ? 'No match.' : 'No players yet. Add one.'}</div>`;
    return;
  }

  list.forEach((p, idx)=>{
    const row = document.createElement('div');
    row.className = 'row ' + (idx%2===1 ? 'alt' : '');
    row.addEventListener('click', ()=>openModal(p));

    const left = document.createElement('div');
    left.className='left';

    const nm = document.createElement('div');
    nm.className='name';
    nm.textContent = displayName(p);

    const meta = document.createElement('div');
    meta.className='meta';
    meta.textContent = `Overall ${p.ratings.overall}`;

    const chips = document.createElement('div');
    chips.className='roleChips';
    if(p.roles.F){ const c=document.createElement('span'); c.className='chip chipF'; c.textContent='Forward'; chips.appendChild(c); }
    if(p.roles.M){ const c=document.createElement('span'); c.className='chip chipM'; c.textContent='Mid'; chips.appendChild(c); }
    if(p.roles.D){ const c=document.createElement('span'); c.className='chip chipD'; c.textContent='Defense'; chips.appendChild(c); }

    const score = computeScore(p);
    const pct = strengthPct(score);
    const color = strengthColor(pct);

    const strength = document.createElement('div');
    strength.className='strength';
    strength.innerHTML = `
      <div class="bar"><div class="fill" style="width:${pct}%;background:${color}"></div></div>
      <div class="num">${Math.round(score)}</div>
    `;

    left.appendChild(nm);
    left.appendChild(meta);
    left.appendChild(chips);
    left.appendChild(strength);

    row.appendChild(left);
    wrap.appendChild(row);
  });
}

function renderResults(sol){
  const wrap = $('results');
  wrap.innerHTML = '';
  const empty = $('resultsEmpty');
  empty.style.display = sol ? 'none' : '';

  if(!sol) return;

  const teamCount = sol.teams.length;
  const names = teamCount===2 ? ['Red','White'] : ['Red','White','Black','Blue'];
  const colors = teamCount===2 ? ['red','white'] : ['red','white','black','blue'];

  sol.teams.forEach((team, i)=>{
    const card = document.createElement('div');
    card.className='teamCard';

    const header = document.createElement('div');
    header.className='teamHeader c-' + colors[i];

    const title = document.createElement('div');
    title.className='teamTitle';
    const shirt = document.createElement('div');
    shirt.className='shirt';
    const tname = document.createElement('div');
    tname.textContent = names[i];
    title.appendChild(shirt);
    title.appendChild(tname);

    const meta = document.createElement('div');
    meta.className='teamMeta';
    meta.innerHTML = `Total ${sol.totals[i].toFixed(0)}<br>Avg ${sol.avgs[i].toFixed(2)}`;

    header.appendChild(title);
    header.appendChild(meta);
    card.appendChild(header);

    const body = document.createElement('div');

    team.slice().sort((a,b)=>displayName(a).localeCompare(displayName(b))).forEach(p=>{
      const line = document.createElement('div');
      line.className='playerLine';

      const nm = document.createElement('div');
      nm.className='pn';
      nm.textContent = displayName(p);

      const grid = document.createElement('div');
      grid.className='roleGrid';

      const f = document.createElement('div');
      f.className = 'roleDot ' + (p.roles?.F ? 'dotF' : 'dotOff');
      f.textContent = 'F';

      const m = document.createElement('div');
      m.className = 'roleDot ' + (p.roles?.M ? 'dotM' : 'dotOff');
      m.textContent = 'M';

      const d = document.createElement('div');
      d.className = 'roleDot ' + (p.roles?.D ? 'dotD' : 'dotOff');
      d.textContent = 'D';

      grid.appendChild(f); grid.appendChild(m); grid.appendChild(d);

      line.appendChild(nm);
      line.appendChild(grid);
      body.appendChild(line);
    });

    card.appendChild(body);
    wrap.appendChild(card);
  });
}

/* =========================
   Actions
   ========================= */
function onTeamCountChange(){
  lastSolution=null;
  renderResults(null);
}

function getSelectedPlayers(){
  return players.filter(p=>selection.has(p.id));
}

function generateTeams(){
  const selected = getSelectedPlayers();
  const teamCount = Number($('teamCount').value);

  if(selected.length < teamCount){
    alert('Select more players first.');
    return;
  }

  // seed changes per generate/regenerate so you get different but balanced solutions
  const baseSeed = (lastSolution?.seed ?? Math.floor(Math.random()*1e9)) + 1337;
  const sol = optimize(selected, teamCount, baseSeed);
  lastSolution = sol;
  renderResults(sol);

  document.getElementById('results').scrollIntoView({behavior:'smooth', block:'start'});
}

function regenerate(){
  if(selection.size===0){ alert('Select players first.'); return; }
  // new seed (different search trajectory) but same selection
  const bump = Math.floor(Math.random()*1e9);
  const selected = getSelectedPlayers();
  const teamCount = Number($('teamCount').value);
  const sol = optimize(selected, teamCount, bump);
  lastSolution = sol;
  renderResults(sol);

  document.getElementById('results').scrollIntoView({behavior:'smooth', block:'start'});
}

function clearSelection(){
  selection.clear();
  save();
  lastSolution=null;
  renderResults(null);
  renderChecklist();
  updateSticky();
}

/* =========================
   Modal CRUD
   ========================= */
function backdropClose(e){
  if(e.target.id==='modalBackdrop') closeModal();
}

function openModal(player){
  $('modalBackdrop').style.display='flex';
  if(player){
    currentEditId = player.id;
    $('modalTitle').textContent = 'Edit Player';
    $('btnDelete').style.display='inline-flex';
    $('fName').value = player.name || '';
    setRoleButtons(player.roles);
    setRatingFields(player.ratings);
  }else{
    currentEditId = null;
    $('modalTitle').textContent = 'Add Player';
    $('btnDelete').style.display='none';
    $('fName').value = '';
    setRoleButtons({F:false,M:true,D:false});
    setRatingFields(defaultRatings());
  }
}

function closeModal(){
  $('modalBackdrop').style.display='none';
}

function setRoleButtons(roles){
  $('btnF').className = roles.F ? 'onF' : '';
  $('btnM').className = roles.M ? 'onM' : '';
  $('btnD').className = roles.D ? 'onD' : '';
}

function toggleRole(r){
  const roles = {
    F: $('btnF').classList.contains('onF'),
    M: $('btnM').classList.contains('onM'),
    D: $('btnD').classList.contains('onD'),
  };
  roles[r] = !roles[r];
  // require at least one role
  if(!roles.F && !roles.M && !roles.D) roles.M = true;
  setRoleButtons(roles);
}

function setRatingFields(r){
  $('rOverall').value = r.overall;
  $('rPassing').value = r.passing;
  $('rDribbling').value = r.dribbling;
  $('rFinishing').value = r.finishing;
  $('rDefense').value = r.defense;
  $('rSpeed').value = r.speed;
  $('rStamina').value = r.stamina;
  $('rClutch').value = r.clutch;
  $('rConsistency').value = r.consistency;
  $('rLeadership').value = r.leadership;
}

function readRolesFromButtons(){
  return {
    F: $('btnF').classList.contains('onF'),
    M: $('btnM').classList.contains('onM'),
    D: $('btnD').classList.contains('onD'),
  };
}

function readRatings(){
  const r = {
    overall: clampInt($('rOverall').value,1,10),
    passing: clampInt($('rPassing').value,1,10),
    dribbling: clampInt($('rDribbling').value,1,10),
    finishing: clampInt($('rFinishing').value,1,10),
    defense: clampInt($('rDefense').value,1,10),
    speed: clampInt($('rSpeed').value,1,10),
    stamina: clampInt($('rStamina').value,1,10),
    clutch: clampInt($('rClutch').value,1,5),
    consistency: clampInt($('rConsistency').value,1,5),
    leadership: clampInt($('rLeadership').value,1,5),
  };
  // reflect clamped values back into inputs (validation)
  setRatingFields(r);
  return r;
}

function saveCurrent(){
  const name = ($('fName').value||'').trim();
  if(!name){ alert('Name is required.'); return; }
  const roles = readRolesFromButtons();
  const ratings = readRatings();

  if(currentEditId){
    const i = players.findIndex(p=>p.id===currentEditId);
    if(i>=0){
      players[i] = { ...players[i], name, roles, ratings };
    }
  }else{
    const p = { id: uid(), name, roles, ratings };
    players.push(p);
  }
  save();
  renderPlayersPage();
  renderChecklist();
  updateSticky();
  closeModal();
}

function deleteCurrent(){
  if(!currentEditId) return;
  if(!confirm('Delete this player?')) return;
  players = players.filter(p=>p.id!==currentEditId);
  selection.delete(currentEditId);
  save();
  lastSolution=null;
  renderResults(null);
  renderPlayersPage();
  renderChecklist();
  updateSticky();
  closeModal();
}

/* =========================
   Import / Export / Demo
   ========================= */
function exportJSON(){
  const data = JSON.stringify(players, null, 2);
  const blob = new Blob([data], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'team-balancer-players.json';
  a.click();
  URL.revokeObjectURL(a.href);
}

function importJSON(){
  const input = document.createElement('input');
  input.type='file';
  input.accept='application/json';
  input.onchange = (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const arr = JSON.parse(reader.result);
        if(!Array.isArray(arr)) throw new Error('JSON must be an array');
        players = arr.map(p=>({
          id: p.id || uid(),
          name: (p.name||'').toString(),
          roles: {F:!!p.roles?.F, M:!!p.roles?.M, D:!!p.roles?.D},
          ratings: {
            overall: clampInt(p.ratings?.overall ?? 6,1,10),
            passing: clampInt(p.ratings?.passing ?? 6,1,10),
            dribbling: clampInt(p.ratings?.dribbling ?? 6,1,10),
            finishing: clampInt(p.ratings?.finishing ?? 6,1,10),
            defense: clampInt(p.ratings?.defense ?? 6,1,10),
            speed: clampInt(p.ratings?.speed ?? 6,1,10),
            stamina: clampInt(p.ratings?.stamina ?? 6,1,10),
            clutch: clampInt(p.ratings?.clutch ?? 3,1,5),
            consistency: clampInt(p.ratings?.consistency ?? 3,1,5),
            leadership: clampInt(p.ratings?.leadership ?? 3,1,5),
          }
        }));
        // clear selection if ids don't match
        selection = new Set();
        save();
        lastSolution=null;
        renderResults(null);
        renderPlayersPage();
        renderChecklist();
        updateSticky();
        alert('Imported.');
      }catch(err){
        alert('Import failed: ' + err.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

function randomizeDemo(){
  // Randomize ratings + roles so you can quickly test balancing + role constraints.
  if(!confirm('Randomize demo data (ratings + roles) for all players?')) return;
  players = players.map((p,i)=>{
    const r = defaultRatings();
    // more distinct roles distribution
    const roll = Math.random();
    let roles;
    if(roll<0.20) roles={F:true,M:false,D:false};
    else if(roll<0.40) roles={F:false,M:true,D:false};
    else if(roll<0.60) roles={F:false,M:false,D:true};
    else if(roll<0.78) roles={F:true,M:true,D:false};
    else if(roll<0.92) roles={F:false,M:true,D:true};
    else roles={F:true,M:true,D:true};
    return {...p, roles, ratings:r};
  });
  save();
  lastSolution=null;
  renderResults(null);
  renderPlayersPage();
  renderChecklist();
  updateSticky();
}

/* =========================
   Init
   ========================= */
load();
switchTab('game'); // default to Game Builder
renderChecklist();
renderPlayersPage();
updateSticky();
</script>
</body>
</html>
